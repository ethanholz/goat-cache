// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: query.sql

package db

import (
	"context"
	"database/sql"
)

const addNarToCache = `-- name: AddNarToCache :exec
INSERT INTO cache_nars (cache_id, nar_id)
VALUES (?, ?)
ON CONFLICT DO NOTHING
`

type AddNarToCacheParams struct {
	CacheID string
	NarID   string
}

func (q *Queries) AddNarToCache(ctx context.Context, arg AddNarToCacheParams) error {
	_, err := q.db.ExecContext(ctx, addNarToCache, arg.CacheID, arg.NarID)
	return err
}

const createCache = `-- name: CreateCache :one

INSERT INTO caches (id, name)
VALUES (?, ?)
RETURNING id, name, created_at, last_accessed_at, updated_at
`

type CreateCacheParams struct {
	ID   string
	Name string
}

// SQLC queries
// Cache operations
func (q *Queries) CreateCache(ctx context.Context, arg CreateCacheParams) (Cach, error) {
	row := q.db.QueryRowContext(ctx, createCache, arg.ID, arg.Name)
	var i Cach
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.CreatedAt,
		&i.LastAccessedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const findConflictingStorePaths = `-- name: FindConflictingStorePaths :many
SELECT n.store_path, 
       COUNT(DISTINCT n.nar_hash) as version_count,
       GROUP_CONCAT(DISTINCT c.name) as cache_names
FROM nars n
JOIN cache_nars cn ON n.id = cn.nar_id
JOIN caches c ON cn.cache_id = c.id
GROUP BY n.store_path
HAVING COUNT(DISTINCT n.nar_hash) > 1
`

type FindConflictingStorePathsRow struct {
	StorePath    string
	VersionCount int64
	CacheNames   string
}

func (q *Queries) FindConflictingStorePaths(ctx context.Context) ([]FindConflictingStorePathsRow, error) {
	rows, err := q.db.QueryContext(ctx, findConflictingStorePaths)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FindConflictingStorePathsRow
	for rows.Next() {
		var i FindConflictingStorePathsRow
		if err := rows.Scan(&i.StorePath, &i.VersionCount, &i.CacheNames); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCache = `-- name: GetCache :one
SELECT id, name, created_at, last_accessed_at, updated_at FROM caches
WHERE name = ? LIMIT 1
`

func (q *Queries) GetCache(ctx context.Context, name string) (Cach, error) {
	row := q.db.QueryRowContext(ctx, getCache, name)
	var i Cach
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.CreatedAt,
		&i.LastAccessedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getNarByHash = `-- name: GetNarByHash :one
SELECT id, store_path, nar_hash, nar_size, chunk_count, created_at, last_accessed_at, updated_at FROM nars
WHERE nar_hash = ? LIMIT 1
`

// NAR operations
func (q *Queries) GetNarByHash(ctx context.Context, narHash string) (Nar, error) {
	row := q.db.QueryRowContext(ctx, getNarByHash, narHash)
	var i Nar
	err := row.Scan(
		&i.ID,
		&i.StorePath,
		&i.NarHash,
		&i.NarSize,
		&i.ChunkCount,
		&i.CreatedAt,
		&i.LastAccessedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getNarsByStorePath = `-- name: GetNarsByStorePath :many
SELECT n.id, n.store_path, n.nar_hash, n.nar_size, n.chunk_count, n.created_at, n.last_accessed_at, n.updated_at, 
       c.name as cache_name,
       c.id as cache_id
FROM nars n
JOIN cache_nars cn ON n.id = cn.nar_id
JOIN caches c ON cn.cache_id = c.id
WHERE n.store_path = ?
ORDER BY n.created_at DESC
`

type GetNarsByStorePathRow struct {
	ID             string
	StorePath      string
	NarHash        string
	NarSize        int64
	ChunkCount     int64
	CreatedAt      string
	LastAccessedAt sql.NullString
	UpdatedAt      string
	CacheName      string
	CacheID        string
}

func (q *Queries) GetNarsByStorePath(ctx context.Context, storePath string) ([]GetNarsByStorePathRow, error) {
	rows, err := q.db.QueryContext(ctx, getNarsByStorePath, storePath)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetNarsByStorePathRow
	for rows.Next() {
		var i GetNarsByStorePathRow
		if err := rows.Scan(
			&i.ID,
			&i.StorePath,
			&i.NarHash,
			&i.NarSize,
			&i.ChunkCount,
			&i.CreatedAt,
			&i.LastAccessedAt,
			&i.UpdatedAt,
			&i.CacheName,
			&i.CacheID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNarsInCacheByStorePath = `-- name: GetNarsInCacheByStorePath :many
SELECT n.id, n.store_path, n.nar_hash, n.nar_size, n.chunk_count, n.created_at, n.last_accessed_at, n.updated_at 
FROM nars n
JOIN cache_nars cn ON n.id = cn.nar_id
JOIN caches c ON cn.cache_id = c.id
WHERE c.name = ? AND n.store_path = ?
ORDER BY n.created_at DESC
`

type GetNarsInCacheByStorePathParams struct {
	Name      string
	StorePath string
}

func (q *Queries) GetNarsInCacheByStorePath(ctx context.Context, arg GetNarsInCacheByStorePathParams) ([]Nar, error) {
	rows, err := q.db.QueryContext(ctx, getNarsInCacheByStorePath, arg.Name, arg.StorePath)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Nar
	for rows.Next() {
		var i Nar
		if err := rows.Scan(
			&i.ID,
			&i.StorePath,
			&i.NarHash,
			&i.NarSize,
			&i.ChunkCount,
			&i.CreatedAt,
			&i.LastAccessedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrphanedNars = `-- name: GetOrphanedNars :many
SELECT n.id, n.store_path, n.nar_hash, n.nar_size, n.chunk_count, n.created_at, n.last_accessed_at, n.updated_at
FROM nars n
LEFT JOIN cache_nars cn ON n.id = cn.nar_id
WHERE cn.cache_id IS NULL
`

// Garbage collection helpers
func (q *Queries) GetOrphanedNars(ctx context.Context) ([]Nar, error) {
	rows, err := q.db.QueryContext(ctx, getOrphanedNars)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Nar
	for rows.Next() {
		var i Nar
		if err := rows.Scan(
			&i.ID,
			&i.StorePath,
			&i.NarHash,
			&i.NarSize,
			&i.ChunkCount,
			&i.CreatedAt,
			&i.LastAccessedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStorePathVersions = `-- name: GetStorePathVersions :many
SELECT n.id, n.store_path, n.nar_hash, n.nar_size, n.chunk_count, n.created_at, n.last_accessed_at, n.updated_at, c.name as cache_name
FROM nars n
JOIN cache_nars cn ON n.id = cn.nar_id
JOIN caches c ON cn.cache_id = c.id
WHERE n.store_path = ?
ORDER BY n.created_at DESC
`

type GetStorePathVersionsRow struct {
	ID             string
	StorePath      string
	NarHash        string
	NarSize        int64
	ChunkCount     int64
	CreatedAt      string
	LastAccessedAt sql.NullString
	UpdatedAt      string
	CacheName      string
}

func (q *Queries) GetStorePathVersions(ctx context.Context, storePath string) ([]GetStorePathVersionsRow, error) {
	rows, err := q.db.QueryContext(ctx, getStorePathVersions, storePath)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetStorePathVersionsRow
	for rows.Next() {
		var i GetStorePathVersionsRow
		if err := rows.Scan(
			&i.ID,
			&i.StorePath,
			&i.NarHash,
			&i.NarSize,
			&i.ChunkCount,
			&i.CreatedAt,
			&i.LastAccessedAt,
			&i.UpdatedAt,
			&i.CacheName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertChunk = `-- name: InsertChunk :one
INSERT INTO chunks (
    id, chunk_hash, size, 
    compression_type, s3_key, etag
)
VALUES (?, ?, ?, ?, ?, ?)
RETURNING id, chunk_hash, size, compression_type, s3_key, etag, created_at
`

type InsertChunkParams struct {
	ID              string
	ChunkHash       string
	Size            int64
	CompressionType sql.NullString
	S3Key           string
	Etag            string
}

// Chunk operations
func (q *Queries) InsertChunk(ctx context.Context, arg InsertChunkParams) (Chunk, error) {
	row := q.db.QueryRowContext(ctx, insertChunk,
		arg.ID,
		arg.ChunkHash,
		arg.Size,
		arg.CompressionType,
		arg.S3Key,
		arg.Etag,
	)
	var i Chunk
	err := row.Scan(
		&i.ID,
		&i.ChunkHash,
		&i.Size,
		&i.CompressionType,
		&i.S3Key,
		&i.Etag,
		&i.CreatedAt,
	)
	return i, err
}

const insertNar = `-- name: InsertNar :one
INSERT INTO nars (
    id, store_path, nar_hash, 
    nar_size, chunk_count
)
VALUES (?, ?, ?, ?, ?)
RETURNING id, store_path, nar_hash, nar_size, chunk_count, created_at, last_accessed_at, updated_at
`

type InsertNarParams struct {
	ID         string
	StorePath  string
	NarHash    string
	NarSize    int64
	ChunkCount int64
}

func (q *Queries) InsertNar(ctx context.Context, arg InsertNarParams) (Nar, error) {
	row := q.db.QueryRowContext(ctx, insertNar,
		arg.ID,
		arg.StorePath,
		arg.NarHash,
		arg.NarSize,
		arg.ChunkCount,
	)
	var i Nar
	err := row.Scan(
		&i.ID,
		&i.StorePath,
		&i.NarHash,
		&i.NarSize,
		&i.ChunkCount,
		&i.CreatedAt,
		&i.LastAccessedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const insertNarChunk = `-- name: InsertNarChunk :exec
INSERT INTO nar_chunks (
    nar_id, chunk_id, chunk_index, offset
)
VALUES (?, ?, ?, ?)
`

type InsertNarChunkParams struct {
	NarID      string
	ChunkID    string
	ChunkIndex int64
	Offset     int64
}

func (q *Queries) InsertNarChunk(ctx context.Context, arg InsertNarChunkParams) error {
	_, err := q.db.ExecContext(ctx, insertNarChunk,
		arg.NarID,
		arg.ChunkID,
		arg.ChunkIndex,
		arg.Offset,
	)
	return err
}

const listNarsInCache = `-- name: ListNarsInCache :many
SELECT n.id, n.store_path, n.nar_hash, n.nar_size, n.chunk_count, n.created_at, n.last_accessed_at, n.updated_at 
FROM nars n
JOIN cache_nars cn ON n.id = cn.nar_id
JOIN caches c ON cn.cache_id = c.id
WHERE c.name = ?
ORDER BY n.store_path
`

func (q *Queries) ListNarsInCache(ctx context.Context, name string) ([]Nar, error) {
	rows, err := q.db.QueryContext(ctx, listNarsInCache, name)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Nar
	for rows.Next() {
		var i Nar
		if err := rows.Scan(
			&i.ID,
			&i.StorePath,
			&i.NarHash,
			&i.NarSize,
			&i.ChunkCount,
			&i.CreatedAt,
			&i.LastAccessedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeNarFromCache = `-- name: RemoveNarFromCache :exec
DELETE FROM cache_nars
WHERE cache_id = ? AND nar_id = ?
`

type RemoveNarFromCacheParams struct {
	CacheID string
	NarID   string
}

func (q *Queries) RemoveNarFromCache(ctx context.Context, arg RemoveNarFromCacheParams) error {
	_, err := q.db.ExecContext(ctx, removeNarFromCache, arg.CacheID, arg.NarID)
	return err
}
